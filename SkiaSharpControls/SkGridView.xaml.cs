using SkiaSharp;
using SkiaSharpControls.Enum;
using SkiaSharpControls.Models;
using System.Collections;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.DirectoryServices;
using System.Drawing;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Threading;


namespace SkiaSharpControls
{
    /// <summary>
    /// Interaction logic for SkGridView.xaml
    /// </summary>
    public partial class SkGridView : UserControl
    {
        public SkGridView()
        {
            InitializeComponent();

            DataListView.ItemsSource = new List<string>() { "" };
            renderer.SetScrollBars(HorizontalScrollViewer, VerticalScrollViewer);

            SizeChanged += (s, o) =>
            {
                UpdateValues();
            };

            Loaded += (s, o) =>
            {
                PresentationTraceSources.DataBindingSource.Switch.Level = SourceLevels.Critical;
                SkiaCanvas.Height = GetSkiaHeight(TotalRows);
                SkiaCanvas.Width = GetSkiaWidth();
                DataListViewScroll = FindScrollViewer(DataListView);
                renderer.SetGridLinesVisibility(ShowGridLines);

                UpdateValues();
                SkiaCanvas.Focus();
                DataListView.AddHandler(
                        DataGridColumnHeader.PreviewMouseDoubleClickEvent,
                        new MouseButtonEventHandler((sender, e) =>
                        {
                            if (e.OriginalSource is FrameworkElement element &&
                                element.TemplatedParent is System.Windows.Controls.Primitives.Thumb)
                            {
                                e.Handled = true; // Cancel default resizing
                            }
                        }),
                        true);

                // InvokeHeaderClickWithDelay();
            };
            //DataListView.AutoGeneratedColumns += (s, e) => InvokeHeaderClickWithDelay();
            // DataListView.ColumnReordered += (s, e) => InvokeHeaderClickWithDelay();
        }


        private bool IsBusy { get; set; }
        private SkGridRenderer renderer = new();
        private int lastSelectedRowIndex = 0;
        private float rowHeight = 12 + 4;
        public Action<object> OnRowClicked
        {
            get { return (Action<object>)GetValue(OnRowClickedProperty); }
            set { SetValue(OnRowClickedProperty, value); }
        }

        // Using a DependencyProperty as the backing store for OnItemClick.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty OnRowClickedProperty =
            DependencyProperty.Register(nameof(OnRowClicked), typeof(Action<object>), typeof(SkGridView), new PropertyMetadata(default));

        public Action<string, SkGridViewColumnSort> SortDirectionChanged
        {
            get { return (Action<string, SkGridViewColumnSort>)GetValue(SortDirectionChangedProperty); }
            set { SetValue(SortDirectionChangedProperty, value); }
        }

        // Using a DependencyProperty as the backing store for OnItemClick.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty SortDirectionChangedProperty =
            DependencyProperty.Register(nameof(SortDirectionChanged), typeof(Action<string, SkGridViewColumnSort>), typeof(SkGridView), new PropertyMetadata(default));

        public Action<SkGridViewColumn> ColumnRightClick
        {
            get { return (Action<SkGridViewColumn>)GetValue(ColumnRightClickProperty); }
            set { SetValue(ColumnRightClickProperty, value); }
        }

        // Using a DependencyProperty as the backing store for OnItemClick.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty ColumnRightClickProperty =
            DependencyProperty.Register(nameof(ColumnRightClick), typeof(Action<SkGridViewColumn>), typeof(SkGridView), new PropertyMetadata(default));

        public Action<SkGridViewColumn> ColumnLeftClick
        {
            get { return (Action<SkGridViewColumn>)GetValue(ColumnLeftClickProperty); }
            set { SetValue(ColumnLeftClickProperty, value); }
        }

        // Using a DependencyProperty as the backing store for OnItemClick.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty ColumnLeftClickProperty =
            DependencyProperty.Register(nameof(ColumnLeftClick), typeof(Action<SkGridViewColumn>), typeof(SkGridView), new PropertyMetadata(default));


        public Action<double> HorizontalScrollBarPositionChanged
        {
            get { return (Action<double>)GetValue(HorizontalScrollBarPositionChangedProperty); }
            set { SetValue(HorizontalScrollBarPositionChangedProperty, value); }
        }

        // Using a DependencyProperty as the backing store for OnItemClick.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty HorizontalScrollBarPositionChangedProperty =
            DependencyProperty.Register(nameof(HorizontalScrollBarPositionChanged), typeof(Action<double>), typeof(SkGridView), new PropertyMetadata(default));

        public Action<double> VerticalScrollBarPositionChanged
        {
            get { return (Action<double>)GetValue(VerticalScrollBarPositionChangedProperty); }
            set { SetValue(VerticalScrollBarPositionChangedProperty, value); }
        }

        // Using a DependencyProperty as the backing store for OnItemClick.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty VerticalScrollBarPositionChangedProperty =
            DependencyProperty.Register(nameof(VerticalScrollBarPositionChanged), typeof(Action<double>), typeof(SkGridView), new PropertyMetadata(default));

        public Action<object> OnRowRightClicked
        {
            get { return (Action<object>)GetValue(OnRowRightClickedProperty); }
            set { SetValue(OnRowRightClickedProperty, value); }
        }

        // Using a DependencyProperty as the backing store for OnItemClick.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty OnRowRightClickedProperty =
            DependencyProperty.Register(nameof(OnRowRightClicked), typeof(Action<object>), typeof(SkGridView), new PropertyMetadata(default));

        public Action<object> OnRowDoubleClicked
        {
            get { return (Action<object>)GetValue(OnRowDoubleClickedProperty); }
            set { SetValue(OnRowDoubleClickedProperty, value); }
        }

        // Using a DependencyProperty as the backing store for OnItemClick.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty OnRowDoubleClickedProperty =
            DependencyProperty.Register(nameof(OnRowDoubleClicked), typeof(Action<object>), typeof(SkGridView), new PropertyMetadata(default));

        public Action OnSkGridDoubleClicked
        {
            get { return (Action)GetValue(OnSkGridDoubleClickedProperty); }
            set { SetValue(OnSkGridDoubleClickedProperty, value); }
        }

        // Using a DependencyProperty as the backing store for OnItemClick.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty OnSkGridDoubleClickedProperty =
            DependencyProperty.Register(nameof(OnSkGridDoubleClicked), typeof(Action), typeof(SkGridView), new PropertyMetadata(default));

        public Action<Key> OnPreviewKeyDownEvent
        {
            get { return (Action<Key>)GetValue(OnPreviewKeyDownEventProperty); }
            set { SetValue(OnPreviewKeyDownEventProperty, value); }
        }

        public static readonly DependencyProperty OnPreviewKeyDownEventProperty =
            DependencyProperty.Register(nameof(OnPreviewKeyDownEvent), typeof(Action<Key>), typeof(SkGridView), new PropertyMetadata(default));

        public Action<object, string> OnCellClicked
        {
            get { return (Action<object, string>)GetValue(OnCellClickedProperty); }
            set { SetValue(OnCellClickedProperty, value); }
        }

        // Using a DependencyProperty as the backing store for OnItemClick.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty OnCellClickedProperty =
            DependencyProperty.Register(nameof(OnCellClicked), typeof(Action<object, string>), typeof(SkGridView), new PropertyMetadata(default));

        public ContextMenu HeaderContextMenu
        {
            get { return (ContextMenu)GetValue(HeaderContextMenuProperty); }
            set { SetValue(HeaderContextMenuProperty, value); }
        }

        // Using a DependencyProperty as the backing store for HeaderContextMenu.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty HeaderContextMenuProperty =
            DependencyProperty.Register(nameof(HeaderContextMenu), typeof(ContextMenu), typeof(SkGridView), new PropertyMetadata(default, OnHeaderContextMenuChanged));

        private static void OnHeaderContextMenuChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView)
            {
                skGridView.DataListView.ContextMenu = e.NewValue as ContextMenu;
            }
        }

        public bool ColumnHeaderVisible
        {
            get { return (bool)GetValue(ColumnHeaderVisibleProperty); }
            set { SetValue(ColumnHeaderVisibleProperty, value); }
        }

        public static readonly DependencyProperty ColumnHeaderVisibleProperty =
            DependencyProperty.Register(
                nameof(ColumnHeaderVisible),
                typeof(bool),
                typeof(SkGridView),
                new PropertyMetadata(true, OnColumnHeaderVisibleChanged));

        private static void OnColumnHeaderVisibleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView)
            {
                skGridView.SKGridColumnHeader.Height = new GridLength((bool)e.NewValue ? 21 : 0);
                skGridView.DataListView.Visibility = (bool)e.NewValue ? Visibility.Visible : Visibility.Hidden;
            }
        }

        public bool HorizontalScrollBarVisible
        {
            get { return (bool)GetValue(HorizontalScrollBarVisibleProperty); }
            set { SetValue(HorizontalScrollBarVisibleProperty, value); }
        }

        // Using a DependencyProperty as the backing store for HorizontalScrollBarVisible.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty HorizontalScrollBarVisibleProperty =
            DependencyProperty.Register(
                nameof(HorizontalScrollBarVisible),
                typeof(bool),
                typeof(SkGridView),
                new PropertyMetadata(true, OnHorizontalScrollBarVisibilityChanged));

        private static void OnHorizontalScrollBarVisibilityChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView)
            {
                skGridView.HorizontalScrollViewer.Visibility = (bool)e.NewValue ? Visibility.Visible : Visibility.Collapsed;
            }
        }


        public bool VerticalScrollBarVisible
        {
            get { return (bool)GetValue(VerticalScrollBarVisibleProperty); }
            set { SetValue(VerticalScrollBarVisibleProperty, value); }
        }

        // Using a DependencyProperty as the backing store for VerticalScrollBarVisible.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty VerticalScrollBarVisibleProperty =
            DependencyProperty.Register(
                nameof(VerticalScrollBarVisible),
                typeof(bool),
                typeof(SkGridView),
                new PropertyMetadata(true, OnVerticalScrollBarVisibilityChanged));

        private static void OnVerticalScrollBarVisibilityChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView)
            {
                skGridView.VerticalScrollViewer.Visibility = (bool)e.NewValue ? Visibility.Visible : Visibility.Collapsed;
            }
        }

        public bool CanUserSelectRows
        {
            get { return (bool)GetValue(CanUserSelectRowsProperty); }
            set { SetValue(CanUserSelectRowsProperty, value); }
        }

        // Using a DependencyProperty as the backing store for VerticalScrollBarVisible.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty CanUserSelectRowsProperty =
            DependencyProperty.Register(
                nameof(CanUserSelectRows),
                typeof(bool),
                typeof(SkGridView),
                new PropertyMetadata(true, CanUserSelectRowsPropertyChanged));

        private static void CanUserSelectRowsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView)
            {
                if (!(bool)e.NewValue)
                    skGridView?.SelectedItems?.Clear();
            }
        }

        public SKFont? Font
        {
            get { return (SKFont?)GetValue(FontProperty); }
            set { SetValue(FontProperty, value); }
        }

        public static readonly DependencyProperty FontProperty =
            DependencyProperty.Register(
                nameof(Font),
                typeof(SKFont),
                typeof(SkGridView),
                new PropertyMetadata(null, FontChanged));

        private static void FontChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView)
            {
                if (e.NewValue != null)
                {
                    skGridView.rowHeight = ((SKFont)e.NewValue).Size + 4;
                    skGridView.DataListView.FontSize = skGridView!.Font!.Size;
                    string skiaFontFamilyName = skGridView!.Font!.Typeface.FamilyName;

                    var skFont = skGridView!.Font!;
                    var skTypeface = skFont.Typeface;
                    var skStyle = skTypeface.FontStyle;

                    // Set FontFamily
                    skGridView.DataListView.FontFamily = new System.Windows.Media.FontFamily(skTypeface.FamilyName);

                    // Map SkiaSharp slant to WPF FontStyle
                    System.Windows.FontStyle wpfFontStyle = FontStyles.Normal;
                    if (skStyle.Slant == SKFontStyleSlant.Italic)
                        wpfFontStyle = FontStyles.Italic;
                    else if (skStyle.Slant == SKFontStyleSlant.Oblique)
                        wpfFontStyle = FontStyles.Oblique;

                    skGridView.DataListView.FontStyle = wpfFontStyle;

                    // Map SkiaSharp weight to WPF FontWeight
                    FontWeight wpfFontWeight = FontWeights.Normal;
                    if (skStyle.Weight >= (int)SKFontStyleWeight.SemiBold)
                        wpfFontWeight = FontWeights.Bold;

                    skGridView.DataListView.FontWeight = wpfFontWeight;

                    skGridView.SKGridColumnHeader.Height = new GridLength(skGridView.ColumnHeaderVisible ? (skGridView!.Font!.Size + 10) : 0);
                }
            }
        }

        public bool CanUserReorderColumns
        {
            get { return (bool)GetValue(CanUserReorderColumnsProperty); }
            set { SetValue(CanUserReorderColumnsProperty, value); }
        }

        // Using a DependencyProperty as the backing store for HorizontalScrollBarVisible.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty CanUserReorderColumnsProperty =
            DependencyProperty.Register(
                nameof(CanUserReorderColumns),
                typeof(bool),
                typeof(SkGridView),
                new PropertyMetadata(true, CanUserReorderColumnsChanged));

        private static void CanUserReorderColumnsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView)
            {
                skGridView.DataListView.CanUserReorderColumns = (bool)e.NewValue;
            }
        }

        public bool CanUserResizeColumns
        {
            get { return (bool)GetValue(CanUserResizeColumnsProperty); }
            set { SetValue(CanUserResizeColumnsProperty, value); }
        }

        // Using a DependencyProperty as the backing store for HorizontalScrollBarVisible.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty CanUserResizeColumnsProperty =
            DependencyProperty.Register(
                nameof(CanUserResizeColumns),
                typeof(bool),
                typeof(SkGridView),
                new PropertyMetadata(true, CanUserResizeColumnsChanged));

        private static void CanUserResizeColumnsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView)
            {
                skGridView.DataListView.CanUserResizeColumns = (bool)e.NewValue;
            }
        }

        public bool CanUserSortColumns
        {
            get { return (bool)GetValue(CanUserSortColumnsProperty); }
            set { SetValue(CanUserSortColumnsProperty, value); }
        }

        // Using a DependencyProperty as the backing store for HorizontalScrollBarVisible.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty CanUserSortColumnsProperty =
            DependencyProperty.Register(
                nameof(CanUserSortColumns),
                typeof(bool),
                typeof(SkGridView),
                new PropertyMetadata(true, CanUserSortColumnsChanged));

        private static void CanUserSortColumnsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView)
            {
                skGridView.DataListView.CanUserSortColumns = (bool)e.NewValue;
            }
        }


        public ContextMenu ContextMenu
        {
            get { return (ContextMenu)GetValue(ContextMenuProperty); }
            set { SetValue(ContextMenuProperty, value); }
        }

        // Using a DependencyProperty as the backing store for HeaderContextMenu.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty ContextMenuProperty =
            DependencyProperty.Register(nameof(ContextMenu), typeof(ContextMenu), typeof(SkGridView), new PropertyMetadata(default, OnContextMenuChanged));

        private static void OnContextMenuChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView)
            {
                skGridView.skiaContainer.ContextMenu = e.NewValue as ContextMenu;
            }
        }

        public ContextMenu ItemsContextMenu
        {
            get { return (ContextMenu)GetValue(ItemsContextMenuProperty); }
            set { SetValue(ItemsContextMenuProperty, value); }
        }

        // Using a DependencyProperty as the backing store for ItemsContextMenu.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty ItemsContextMenuProperty =
            DependencyProperty.Register(nameof(ItemsContextMenu), typeof(ContextMenu), typeof(SkGridView), new PropertyMetadata(default, OnItemsContextMenuChanged));

        private static void OnItemsContextMenuChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView)
            {
                skGridView.SkiaCanvas.ContextMenu = e.NewValue as ContextMenu;
            }
        }

        public IEnumerable<SkGridViewColumn> Columns
        {
            get { return (IEnumerable<SkGridViewColumn>)GetValue(ColumnsProperty); }
            set { SetValue(ColumnsProperty, value); }
        }

        // Using a DependencyProperty as the backing store for Columns.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty ColumnsProperty =
            DependencyProperty.Register(nameof(Columns), typeof(IEnumerable<SkGridViewColumn>), typeof(SkGridView), new PropertyMetadata(default, OnColumnsChanged));

        private static void OnColumnsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            try
            {
 if (d is SkGridView skGridView && e.NewValue is IEnumerable<SkGridViewColumn> columns)
            {
                skGridView.IsBusy = true;
                //skGridView.DataListView.ColumnReordered -= skGridView.DataListView_ColumnReordered;
                skGridView.DataListView.Columns.Clear();

                foreach (var column in columns)
                {
                    var headerStyle = new Style(typeof(DataGridColumnHeader));
                    headerStyle.Setters.Add(new Setter(HorizontalContentAlignmentProperty, column.ContentAlignment == Enum.CellContentAlignment.Right ? HorizontalAlignment.Right :
                                                                                         column.ContentAlignment == Enum.CellContentAlignment.Left ? HorizontalAlignment.Left : HorizontalAlignment.Center));

                    headerStyle.Setters.Add(new Setter(BackgroundProperty, GetColorBrush(column.BackColor ?? "#FF3F3F3F")));


                    headerStyle.BasedOn = skGridView.Resources["ColumnHeaderStyle"] as Style;

                    var dgColumn = new DataGridTextColumn
                    {
                        Header = column.DisplayHeader ?? column.Header,
                        Width = column.Width,
                        Visibility = !column.IsVisible ? Visibility.Collapsed : Visibility.Visible,
                        HeaderStyle = headerStyle,
                        MinWidth = 30,
                    };

                    if (column.CanUserResize.HasValue)
                        dgColumn.CanUserResize = column.CanUserResize.Value;
                    if (column.CanUserReorder.HasValue)
                        dgColumn.CanUserReorder = column.CanUserReorder.Value;
                    if (column.CanUserSort.HasValue)
                        dgColumn.CanUserSort = column.CanUserSort.Value;
                    skGridView.DataListView.Columns.Add(dgColumn);
                }
                var sortColumns = columns.Where(x => x?.GridViewColumnSort != null && x?.GridViewColumnSort != SkGridViewColumnSort.None).LastOrDefault();
                if (sortColumns != null)
                {
                    skGridView!.DataListView.Columns!.Where(x => x.Header as string == (sortColumns.DisplayHeader ?? sortColumns.Header)).FirstOrDefault()!
                                                    .SortDirection = sortColumns.GridViewColumnSort == SkGridViewColumnSort.Ascending ? ListSortDirection.Ascending
                                                                    : (sortColumns.GridViewColumnSort == SkGridViewColumnSort.Descending ? ListSortDirection.Descending : null);
                }
                skGridView.renderer.SetColumns(columns);
                skGridView.IsBusy = false;
                skGridView.SkiaCanvas.InvalidateVisual();
                skGridView.ColumnsChanged?.Invoke();
                skGridView.MonitorColumnResize(skGridView.DataListView);

                // skGridView.InvokeHeaderClickWithDelay();

                //skGridView.DataListView.ColumnReordered += skGridView.DataListView_ColumnReordered;

                //skGridView.GV.Columns.CollectionChanged -= skGridView.OnColumnsReordered;
                //skGridView.GV.Columns.Clear();

                //foreach (var column in columns)
                //{
                //    skGridView.GV.Columns.Add(new GridViewColumn() { Header = column.Header, Width = column.Width });
                //}

                //skGridView.renderer.SetColumns(columns);
                //skGridView.IsBusy = false;
                //skGridView.SkiaCanvas.InvalidateVisual();
                //skGridView.ColumnsChanged?.Invoke();
                //skGridView.GV.Columns.CollectionChanged += skGridView.OnColumnsReordered;
            }
            }
            catch (Exception)
            {
            }
           
        }

        private static SolidColorBrush GetColorBrush(string Color)
        {
            string bgcolorString = Color;
            var bgcolor = (System.Windows.Media.Color)System.Windows.Media.ColorConverter.ConvertFromString(bgcolorString);
            return new SolidColorBrush(bgcolor);
        }

        //private void OnColumnsReordered(object? sender, NotifyCollectionChangedEventArgs e)
        //{
        //    if (sender is ICollection<GridViewColumn> items)
        //    {
        //        IEnumerable<SkGridViewColumn> columns = [];

        //        foreach (var item in items)
        //        {
        //            var existingItem = Columns.FirstOrDefault(x => x.Header == item.Header?.ToString());

        //            columns = columns.Append(new SkGridViewColumn()
        //            {
        //                Header = existingItem?.Header ?? "",
        //                Width = existingItem?.Width ?? 100,
        //            });
        //        }

        //        Columns = columns;
        //        renderer.SetColumns(columns);
        //    }
        //}

        public Action ColumnsChanged
        {
            get { return (Action)GetValue(ColumnsChangedProperty); }
            set { SetValue(ColumnsChangedProperty, value); }
        }

        // Using a DependencyProperty as the backing store for ColumnsChanged.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty ColumnsChangedProperty =
            DependencyProperty.Register(nameof(ColumnsChanged), typeof(Action), typeof(SkGridView), new PropertyMetadata(default));

        public IEnumerable ItemsSource
        {
            get { return (IEnumerable)GetValue(ItemsSourceProperty); }
            set { SetValue(ItemsSourceProperty, value); }
        }

        // Using a DependencyProperty as the backing store for ItemsSource.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty ItemsSourceProperty =
            DependencyProperty.Register(nameof(ItemsSource), typeof(IEnumerable), typeof(SkGridView), new PropertyMetadata(default, OnItemsSourceChanged));

        private static void OnItemsSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView && e.NewValue is IEnumerable list)
            {
                if (list != null)
                {
                    var listCount = list.Cast<object>().Count();
                    skGridView.SkiaCanvas.InvalidateVisual();

                    if (listCount > 0)
                    {
                        skGridView.TotalRows = listCount;
                        skGridView.VerticalScrollViewer.Maximum = skGridView.SkiaCanvas.ActualHeight - skGridView.MainGrid.ActualHeight;
                    }
                    else
                    {
                        skGridView.TotalRows = 0;
                        skGridView.VerticalScrollViewer.Maximum = 0;
                    }
                    skGridView.lastSelectedRowIndex = 0;
                }
                skGridView?.UpdateValues();
            }
        }

        private double GetSkiaHeight(int totalRows)
        {
            if (MainGrid.ActualHeight < (totalRows * rowHeight))
            {
                return MainGrid.ActualHeight;
            }
            return (totalRows * rowHeight);
        }


        private double GetSkiaWidth()
        {
            var totalcolumnwidth = DataListView.Columns.Where(x => x.Visibility == Visibility.Visible).Sum(x => x.Width.Value);
            if (MainGrid.ActualWidth > totalcolumnwidth)
            {
                return totalcolumnwidth;
            }
            return MainGrid.ActualWidth;
        }


        public ObservableCollection<object> SelectedItems
        {
            get { return (ObservableCollection<object>)GetValue(SelectedItemsProperty); }
            set { SetValue(SelectedItemsProperty, value); }
        }

        // Using a DependencyProperty as the backing store for SelectedItems.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty SelectedItemsProperty =
            DependencyProperty.Register(nameof(SelectedItems), typeof(ObservableCollection<object>), typeof(SkGridView), new PropertyMetadata(default, OnSelectedItemsChanged));

        private static void OnSelectedItemsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView && e.NewValue is ObservableCollection<object>)
            {
                skGridView.SkiaCanvas.InvalidateVisual();
            }
        }

        public Func<object, SKColor> RowBackgroundSelector
        {
            get => (Func<object, SKColor>)GetValue(RowBackgroundSelectorProperty);
            set => SetValue(RowBackgroundSelectorProperty, value);
        }

        public static readonly DependencyProperty RowBackgroundSelectorProperty =
            DependencyProperty.Register(nameof(RowBackgroundSelector), typeof(Func<object, SKColor>), typeof(SkGridView), new PropertyMetadata(default, OnRowBackgroundTemplateChanged));

        private static void OnRowBackgroundTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView && e.NewValue is Func<object, SKColor> template)
            {
                skGridView.renderer.SetRowBackgroundSelector(template);
            }
        }

        public Func<object, SKColor> RowBorderSelector
        {
            get => (Func<object, SKColor>)GetValue(RowBorderSelectorProperty);
            set => SetValue(RowBorderSelectorProperty, value);
        }

        public static readonly DependencyProperty RowBorderSelectorProperty =
            DependencyProperty.Register(nameof(RowBorderSelector), typeof(Func<object, SKColor>), typeof(SkGridView), new PropertyMetadata(default, OnRowBorderTemplateChanged));

        private static void OnRowBorderTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView && e.NewValue is Func<object, SKColor> template)
            {
                skGridView.renderer.SetRowBorderSelector(template);
            }
        }

        public Func<object, string, SkCellTemplate> CellTemplateSelector
        {
            get => (Func<object, string, SkCellTemplate>)GetValue(CellTemplateSelectorProperty);
            set => SetValue(CellTemplateSelectorProperty, value);
        }

        public static readonly DependencyProperty CellTemplateSelectorProperty =
            DependencyProperty.Register(nameof(CellTemplateSelector), typeof(Func<object, string, SkCellTemplate>), typeof(SkGridView), new PropertyMetadata(default, OnCellTemplateChanged));

        private static void OnCellTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView && e.NewValue is Func<object, string, SkCellTemplate> template)
            {
                skGridView.renderer.SetCellTemplateSelector(template);
            }
        }

        public bool ShowGridLines
        {
            get { return (bool)GetValue(ShowGridLinesProperty); }
            set { SetValue(ShowGridLinesProperty, value); }
        }

        // Using a DependencyProperty as the backing store for ShowGridLines.  This enables animation, styling, binding, etc...
        public static readonly DependencyProperty ShowGridLinesProperty =
            DependencyProperty.Register(nameof(ShowGridLines), typeof(bool), typeof(SkGridView), new PropertyMetadata(true, OnShowGridLinesChanged));

        private static void OnShowGridLinesChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is SkGridView skGridView && e.NewValue is bool showGridLines)
            {
                skGridView.renderer.SetGridLinesVisibility(showGridLines);
            }
        }

        private Dictionary<UIElement, (bool removeOnLostFocus, bool removeOnReturn)> AddedWpfElements { get; set; } = [];

        public void AddWpfElement(FrameworkElement element, bool removeOnLostFocus = true, bool removeOnReturn = true)
        {
            VerticalScrollViewer.Value = VerticalScrollViewer.ViewportSize;

            if (VerticalScrollViewer.Track.Visibility != Visibility.Visible)
            {
                element.Margin = new Thickness(0, 0, 0, -rowHeight);
            }

            if (!AddedWpfElements.TryAdd(element, (removeOnLostFocus, removeOnReturn)))
                AddedWpfElements[element] = (removeOnLostFocus, removeOnReturn);


            skiaContainer.Children.Add(element);

            if (element is TextBox)
                element.Focus();

            element.KeyDown -= RemoveWpfElementOnEnterPressed(element);

            if (removeOnReturn)
            {
                element.KeyDown += RemoveWpfElementOnEnterPressed(element);
            }

            element.IsKeyboardFocusWithinChanged -= RemoveWpfElementOnLostFocus(element);

            if (removeOnLostFocus)
            {
                element.IsKeyboardFocusWithinChanged += RemoveWpfElementOnLostFocus(element);
            }
        }

        private DependencyPropertyChangedEventHandler RemoveWpfElementOnLostFocus(FrameworkElement element)
        {
            return (obj, e) =>
            {
                if (e.NewValue is bool isFocussed && !isFocussed)
                {
                    skiaContainer.Children.Remove(element);
                    AddedWpfElements.Remove(element);
                }
            };
        }

        private KeyEventHandler RemoveWpfElementOnEnterPressed(FrameworkElement element)
        {
            return (obj, e) =>
            {
                if (e.Key == Key.Enter || e.Key == Key.Return)
                {
                    skiaContainer.Children.Remove(element);
                    AddedWpfElements.Remove(element);
                }
            };
        }

        private void RemoveWpfElements()
        {
            if (AddedWpfElements.Count > 0)
            {
                foreach (var item in AddedWpfElements.Where(x => x.Value.removeOnLostFocus))
                {
                    skiaContainer.Children.Remove(item.Key);
                    AddedWpfElements.Remove(item.Key);
                }
            }
        }

        private void OnPaintSurface(object sender, SkiaSharp.Views.Desktop.SKPaintSurfaceEventArgs e)
        {
            if (IsBusy)
            {
                return;
            }

            SKCanvas canvas = e.Surface.Canvas;
            canvas.Clear();
            SetScale(canvas);
            canvas.Save();
            canvas.Translate(-ScrollOffsetX, -ScrollOffsetY);
            Draw(canvas);
            canvas.Restore();
        }

        private void Draw(SKCanvas canvas)
        {
            renderer.UpdateItems(ItemsSource);
            renderer.UpdateSelectedItems(SelectedItems);
            try
            {
                renderer.Draw(canvas, ScrollOffsetX, ScrollOffsetY, Font, rowHeight, TotalRows);
            }
            catch (Exception ex)
            {

            }

        }

        private void SetScale(SKCanvas canvas)
        {
            PresentationSource source = PresentationSource.FromVisual(this);
            if (source != null)
            {
                var res = source.CompositionTarget.TransformToDevice.M11;
                canvas.Scale((float)res);
            }
            else
            {
                canvas.Scale(GetSystemDpi());
            }
        }

        public static float GetSystemDpi()
        {
            using Graphics g = Graphics.FromHwnd(IntPtr.Zero);
            return g.DpiX / 96.0f; // 96 DPI is the default (100% scaling)
        }

        private void SkiaCanvas_MouseLeftButtonDown(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            if (ItemsSource.Cast<object>().Count() == 0)
                return;
            var point = e.GetPosition(SkiaCanvas);

            int rowIndex = (int)((point.Y + ScrollOffsetY) / rowHeight);
            double x = point.X + ScrollOffsetX;
            int clickedColumnIndex = (int)((point.X + ScrollOffsetX));
            var s = new List<dynamic>((IEnumerable<dynamic>)ItemsSource);

            if (SelectedItems == null)
                SelectedItems = new();


            if (rowIndex > s.Count - 1)
                return;

            foreach (var item in DataListView.Columns.Where(x => x.Visibility == Visibility.Visible))
            {
                x -= item.Width.Value;
                if (x <= 0)
                {
                    OnCellClicked?.Invoke(s[rowIndex], item.Header?.ToString());
                    break;
                }
            }
            if (e.LeftButton == MouseButtonState.Pressed && (Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl)) && CanUserSelectRows)
            {
                if (SelectedItems.Any(x => x.Equals(s[rowIndex])))
                {
                    SelectedItems.Remove(s[rowIndex]);

                }
                else
                {
                    SelectedItems.Add(s[rowIndex]);
                    lastSelectedRowIndex = rowIndex;
                }
            }
            else if (e.LeftButton == MouseButtonState.Pressed && (Keyboard.IsKeyDown(Key.LeftShift) || Keyboard.IsKeyDown(Key.RightShift)) && CanUserSelectRows)
            {
                if (SelectedItems != null && SelectedItems.Count > 0)
                {
                    var seletedRow = lastSelectedRowIndex;

                    var lastIndex = s.IndexOf(s[rowIndex]);

                    if (lastIndex < seletedRow)
                    {
                        SelectedItems.Clear();
                        for (int i = lastIndex; i <= seletedRow; i++)
                        {
                            SelectedItems.Add(s[i]);
                        }
                    }
                    else
                    {
                        SelectedItems.Clear();
                        for (int i = seletedRow; i < lastIndex; i++)
                        {
                            SelectedItems.Add(s[i]);
                        }
                    }
                }

            }
            else if (e.LeftButton == MouseButtonState.Pressed)
            {
                if (CanUserSelectRows)
                {
                    SelectedItems.Clear();
                    SelectedItems.Add(s[rowIndex]);
                    lastSelectedRowIndex = rowIndex;
                }
                OnRowClicked?.Invoke(s[rowIndex]);
            }

            if (e.ClickCount == 2)
                OnRowDoubleClicked?.Invoke(s[rowIndex]);
            SkiaCanvas.InvalidateVisual();
            SkiaCanvas.Focus();
        }
        private void SkiaCanvas_MouseRightButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (ItemsSource.Cast<object>().Count() == 0)
                return;
            // Get mouse position relative to SKElement
            var point = e.GetPosition(SkiaCanvas);

            int rowIndex = (int)((point.Y + ScrollOffsetY) / rowHeight);
            double x = point.X + ScrollOffsetX;
            int clickedColumnIndex = (int)((point.X + ScrollOffsetX));

            var s = new List<dynamic>((IEnumerable<dynamic>)ItemsSource);
            if (rowIndex > s.Count - 1)
                return;



            foreach (var item in DataListView.Columns.Where(x => x.Visibility == Visibility.Visible))
            {
                x -= item.Width.Value;
                if (x <= 0)
                {
                    OnCellClicked?.Invoke(s[rowIndex], item.Header?.ToString());
                    break;
                }
            }

            if (e.RightButton == MouseButtonState.Pressed)
                OnRowRightClicked?.Invoke(s[rowIndex]);

            RemoveWpfElements();
            SkiaCanvas.Focus();
        }
        //private void OnDragStarted(object sender, System.Windows.Controls.Primitives.DragStartedEventArgs e)
        //{
        //    RemoveWpfElements();
        //    IsBusy = true;
        //}

        //private void OnDragCompleted(object sender, System.Windows.Controls.Primitives.DragCompletedEventArgs e)
        //{
        //    IsBusy = false;

        //    if (GV.Columns is ICollection<GridViewColumn> items)
        //    {
        //        IEnumerable<SkGridViewColumn> columns = [];

        //        foreach (var item in items)
        //        {
        //            var existingItem = Columns.FirstOrDefault(x => x.Header == item.Header?.ToString());

        //            columns = columns.Append(new SkGridViewColumn()
        //            {
        //                Header = existingItem?.Header ?? "",
        //                Width = item.Width,
        //            });
        //        }

        //        Columns = columns;
        //    }
        //    UpdateValues();
        //}

        public void Refresh()
        {
            TotalRows = ItemsSource.Cast<object>().Count();
            UpdateValues();
            SkiaCanvas.InvalidateVisual();
        }

        public List<string> FakeList { get; set; } = new() { "" };
        private float ScrollOffsetX = 0, ScrollOffsetY = 0;
        private int TotalRows = 0;
        private int TotalCols = 61;
        private float ColWidth = 90;

        private ScrollViewer DataListViewScroll;
        private float DpiScalling = 0;
        private SKFont TextFont;


        private void VerticalScrollViewer_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            RemoveWpfElements();
            ScrollOffsetY = (float)e.NewValue;
            VerticalScrollBarPositionChanged?.Invoke(e.NewValue);
            SkiaCanvas.InvalidateVisual();
        }
        private void HorizontalScrollViewer_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            ScrollOffsetX = (float)(e.NewValue);
            DataListViewScroll.ScrollToHorizontalOffset(ScrollOffsetX);
            HorizontalScrollBarPositionChanged?.Invoke(e.NewValue);
            SkiaCanvas.InvalidateVisual();
        }
        //private void AddColumnWidthChangedHandler(System.Windows.Controls.ListView listView)
        //{
        //    if (listView.View is GridView gridView)
        //    {
        //        foreach (var column in gridView.Columns)
        //        {
        //            DependencyPropertyDescriptor.FromProperty(GridViewColumn.WidthProperty, typeof(GridViewColumn))
        //                .AddValueChanged(column, OnColumnWidthChanged);
        //        }
        //    }
        //}
        private void MonitorColumnResize(DataGrid dataGrid)
        {
            try
            {
                foreach (var column in dataGrid.Columns)
                {
                    var descriptor = DependencyPropertyDescriptor.FromProperty(DataGridColumn.WidthProperty, typeof(DataGridColumn));
                    descriptor?.AddValueChanged(column, OnColumnWidthChanged);
                }
            }
            catch (Exception)
            {
            }

        }
        private void OnColumnWidthChanged(object sender, EventArgs e)
        {
            IsBusy = false;
            try
            {
                if (sender is DataGridTextColumn column)
                {

                    Columns.FirstOrDefault(x => x.Header == column?.Header.ToString() || x.DisplayHeader == column?.Header.ToString()).Width = column.ActualWidth;
                    UpdateValues();
                    SkiaCanvas.InvalidateVisual();
                }
            }
            catch (Exception)
            {

            }

        }

        private static ScrollViewer FindScrollViewer(DependencyObject parent)
        {
            if (parent is ScrollViewer)
                return (ScrollViewer)parent;

            for (int i = 0; i < VisualTreeHelper.GetChildrenCount(parent); i++)
            {
                var child = VisualTreeHelper.GetChild(parent, i);
                var result = FindScrollViewer(child);
                if (result != null)
                    return result;
            }
            return null;
        }

        private void UpdateValues()
        {
            SkiaCanvas.Height = GetSkiaHeight(TotalRows);
            SkiaCanvas.Width = GetSkiaWidth();
            var TotalColsVisible = DataListView.Columns.Where(x => x.Visibility == Visibility.Visible).Select(x => x.Width.Value);
            ColWidth = (float)(TotalColsVisible.Sum() / (TotalColsVisible.Count() - 1));

            TotalCols = 0;

            HorizontalScrollViewer.Minimum = 0;
            HorizontalScrollViewer.ViewportSize = MainGrid.ActualWidth;
            HorizontalScrollViewer.Maximum = (TotalColsVisible.Sum() + 10) - MainGrid.ActualWidth + 10;

            VerticalScrollViewer.Minimum = 0;
            VerticalScrollViewer.ViewportSize = MainGrid.ActualHeight;
            VerticalScrollViewer.Maximum = ((TotalRows + 3.3) * rowHeight) - MainGrid.ActualHeight;

            PresentationSource source = PresentationSource.FromVisual(this);
            if (source != null)
            {
                var res = source.CompositionTarget.TransformToDevice.M11;
                DpiScalling = (float)res;
            }
            else
            {
                DpiScalling = GetSystemDpi();
            }
        }
        public void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        public event PropertyChangedEventHandler PropertyChanged;

        private void MainGrid_MouseDown(object sender, MouseButtonEventArgs e)
        {
            SkiaCanvas.Focus();
            RemoveWpfElements();
        }

        private void MainGrid_MouseWheel(object sender, MouseWheelEventArgs e)
        {
            if (Keyboard.IsKeyDown(Key.LeftShift) || Keyboard.IsKeyDown(Key.RightShift))
            {

                HorizontalScrollViewer.Value -= e.Delta / 1;
            }
            else
            {
                VerticalScrollViewer.Value -= e.Delta / 1;
            }
        }

        public void ScrollToHorizontalOffset(double offset)
        {
            HorizontalScrollViewer.Value = offset;
        }

        // Declare this to track where the selection started
        private int? _selectionAnchorIndex = null;

        private void SkiaCanvas_KeyDown(object sender, KeyEventArgs e)
        {
            if (ItemsSource is not IEnumerable<dynamic> sourceEnumerable)
                return;

            var items = new List<dynamic>(sourceEnumerable);
            if (items.Count == 0)
                return;

            if (SelectedItems == null || SelectedItems.Count == 0)
            {
                return;
            }
            bool isShift = (Keyboard.IsKeyDown(Key.LeftShift) || Keyboard.IsKeyDown(Key.RightShift));


            if (SelectedItems.Count == 1)
            {
                _selectionAnchorIndex = lastSelectedRowIndex;
            }

            int currentIndex = items.IndexOf(SelectedItems.Last());

            if (!isShift)
                _selectionAnchorIndex = null;

            int firstVisibleRow = Math.Max(0, (int)(ScrollOffsetY / rowHeight));
            int visibleRowCount = Math.Min((int?)(VerticalScrollViewer?.ViewportSize / rowHeight - 3) ?? 0, TotalRows - firstVisibleRow);
            // Shift + Up
            if (isShift && e.Key == Key.Up)
            {
                if (currentIndex == 0)
                {
                    e.Handled = true;
                    Keyboard.Focus(SkiaCanvas);
                    return;
                }

                if (_selectionAnchorIndex == null)
                    _selectionAnchorIndex = currentIndex;

                if (currentIndex > 0)
                {
                    var newIndex = currentIndex - 1;
                    var newItem = items[newIndex];

                    if (newIndex < _selectionAnchorIndex)
                        SelectedItems.Add(newItem);
                    else
                        SelectedItems.Remove(items[currentIndex]);

                    e.Handled = true;
                    Keyboard.Focus(SkiaCanvas);
                    if (currentIndex <= firstVisibleRow)
                    {
                        ScrollToVerticalOffset(ScrollOffsetY - rowHeight);
                    }
                    SkiaCanvas.InvalidateVisual();
                }
            }
            // Shift + Down
            else if (isShift && e.Key == Key.Down)
            {
                if (currentIndex == items.Count - 1)
                {
                    e.Handled = true;
                    Keyboard.Focus(SkiaCanvas);
                    return;
                }
                if (_selectionAnchorIndex == null)
                    _selectionAnchorIndex = currentIndex;

                if (currentIndex < items.Count - 1)
                {
                    var newIndex = currentIndex + 1;
                    var newItem = items[newIndex];

                    if (newIndex > _selectionAnchorIndex)
                        SelectedItems.Add(newItem);
                    else
                        SelectedItems.Remove(items[currentIndex]);

                    e.Handled = true;
                    Keyboard.Focus(SkiaCanvas);
                    if (currentIndex >= firstVisibleRow + visibleRowCount)
                    {
                        ScrollToVerticalOffset(ScrollOffsetY + rowHeight);
                    }
                    SkiaCanvas.InvalidateVisual();
                }
            }
            // Normal Up (no shift) – move single selection
            else if (e.Key == Key.Up)
            {
                if (currentIndex == 0)
                {
                    e.Handled = true;
                    Keyboard.Focus(SkiaCanvas);
                    return;
                }
                if (currentIndex > 0)
                {
                    SelectedItems.Clear();
                    SelectedItems.Add(items[currentIndex - 1]);
                    _selectionAnchorIndex = currentIndex - 1;

                    e.Handled = true;
                    Keyboard.Focus(SkiaCanvas);
                    if (currentIndex <= firstVisibleRow)
                    {
                        ScrollToVerticalOffset(ScrollOffsetY - rowHeight);
                    }
                    SkiaCanvas.InvalidateVisual();
                }
            }
            // Normal Down (no shift)
            else if (e.Key == Key.Down)
            {
                if (currentIndex == items.Count - 1)
                {
                    e.Handled = true;
                    Keyboard.Focus(SkiaCanvas);
                    return;
                }
                if (currentIndex < items.Count - 1)
                {
                    SelectedItems.Clear();
                    SelectedItems.Add(items[currentIndex + 1]);
                    _selectionAnchorIndex = currentIndex + 1;

                    e.Handled = true;
                    Keyboard.Focus(SkiaCanvas);
                    if (currentIndex >= firstVisibleRow + visibleRowCount)
                    {
                        ScrollToVerticalOffset(ScrollOffsetY + rowHeight);
                    }
                    SkiaCanvas.InvalidateVisual();
                }
            }


            OnPreviewKeyDownEvent?.Invoke(e.Key);
        }


        private void SkiaCanvas_LostFocus(object sender, RoutedEventArgs e)
        {
            try
            {
                if (SelectedItems != null && SelectedItems?.Count > 0 && CanUserSelectRows)
                {
                    SelectedItems?.Clear();
                    SkiaCanvas.InvalidateVisual();
                }
            }
            catch { }
        }

        private void skiaContainer_PreviewMouseDown(object sender, MouseButtonEventArgs e)
        {
            if (e.OriginalSource is not SkiaSharp.Views.WPF.SKElement)
            {
                if (SelectedItems?.Count > 0 && !(Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl)) && CanUserSelectRows)
                {
                    SelectedItems.Clear();
                    SkiaCanvas.InvalidateVisual();
                }
                if (e.ClickCount == 2)
                {
                    OnSkGridDoubleClicked?.Invoke();
                }
            }
        }

        private void DataListView_ColumnReordered(object sender, DataGridColumnEventArgs e)
        {
            if (sender is DataGrid items)
            {
                var columns = new List<SkGridViewColumn>();

                foreach (var item in items.Columns.OrderBy(c => c.DisplayIndex))
                {
                    var existingItem = Columns.FirstOrDefault(x => x.Header == item.Header?.ToString() || x.DisplayHeader == item.Header?.ToString());

                    columns.Add(new SkGridViewColumn
                    {
                        Header = existingItem?.Header ?? item.Header?.ToString() ?? "",
                        Width = item.Width.DisplayValue,
                        DisplayHeader = existingItem?.DisplayHeader,
                        BackColor = existingItem?.BackColor,
                        GridViewColumnSort = existingItem.GridViewColumnSort,
                        ContentAlignment = existingItem.ContentAlignment,
                        IsVisible = existingItem.IsVisible
                    });
                }

                Columns = columns;
                renderer.SetColumns(columns);
            }
        }

        private void DataListView_ColumnHeaderDragStarted(object sender, System.Windows.Controls.Primitives.DragStartedEventArgs e)
        {
            //IsBusy = true;
        }

        private void DataListView_ColumnHeaderDragCompleted(object sender, System.Windows.Controls.Primitives.DragCompletedEventArgs e)
        {


            //IsBusy = false;

            //if (sender is ICollection<DataGridColumn> items)
            //{
            //    IEnumerable<SkGridViewColumn> columns = [];

            //    foreach (var item in items)
            //    {
            //        var existingItem = Columns.FirstOrDefault(x => x.Header == item.Header?.ToString());

            //        columns = columns.Append(new SkGridViewColumn()
            //        {
            //            Header = existingItem?.Header ?? "",
            //            Width = item.Width.Value,
            //        });
            //    }

            //    Columns = columns;
            //}
            //UpdateValues();
        }

        private void DataListView_Sorting(object sender, DataGridSortingEventArgs e)
        {
            e.Handled = false;

            var column = e.Column;
            var direction = column.SortDirection != ListSortDirection.Ascending
                ? SkGridViewColumnSort.Ascending
                : SkGridViewColumnSort.Descending;

            column.SortDirection = column.SortDirection != ListSortDirection.Ascending
                ? ListSortDirection.Ascending
                : ListSortDirection.Descending;

            foreach (var item in Columns)
            {
                item.GridViewColumnSort = SkGridViewColumnSort.None;
            }
            var col = Columns.FirstOrDefault(x => x.Header == column?.Header.ToString() || x.DisplayHeader == column?.Header.ToString());
            col.GridViewColumnSort = direction;
            SortDirectionChanged?.Invoke(col.Header, direction);
        }

        private void InvokeHeaderClickWithDelay()
        {
            Dispatcher.BeginInvoke(new Action(() =>
            {
                InvokeDataGridHeaderClick();
            }), DispatcherPriority.Loaded);
        }
        private void InvokeDataGridHeaderClick()
        {
            var headers = FindVisualChildren<DataGridColumnHeader>(DataListView);
            foreach (var header in headers)
            {
                header.RemoveHandler(UIElement.PreviewMouseLeftButtonDownEvent, new MouseButtonEventHandler(ColumnHeader_LeftClick));
                header.RemoveHandler(UIElement.PreviewMouseRightButtonDownEvent, new MouseButtonEventHandler(ColumnHeader_RightClick));

                header.AddHandler(UIElement.PreviewMouseLeftButtonDownEvent, new MouseButtonEventHandler(ColumnHeader_LeftClick), true);
                header.AddHandler(UIElement.PreviewMouseRightButtonDownEvent, new MouseButtonEventHandler(ColumnHeader_RightClick), true);
            }
        }
        private void ColumnHeader_LeftClick(object sender, MouseButtonEventArgs e)
        {
            if (sender is DataGridColumnHeader header)
            {
                var col = Columns?.FirstOrDefault(x => x.Header == header.Content.ToString() || x.DisplayHeader == header.Content.ToString());
                ColumnLeftClick?.Invoke(col!);
            }
        }

        private void ColumnHeader_RightClick(object sender, MouseButtonEventArgs e)
        {
            if (sender is DataGridColumnHeader header)
            {
                var col = Columns.FirstOrDefault(x => x.Header == header.Content.ToString() || x.DisplayHeader == header.Content.ToString());
                ColumnRightClick?.Invoke(col!);
            }
        }
        private static IEnumerable<T> FindVisualChildren<T>(DependencyObject depObj) where T : DependencyObject
        {
            if (depObj != null)
            {
                for (int i = 0; i < VisualTreeHelper.GetChildrenCount(depObj); i++)
                {
                    DependencyObject child = VisualTreeHelper.GetChild(depObj, i);
                    if (child != null && child is T t)
                    {
                        yield return t;
                    }

                    foreach (T childOfChild in FindVisualChildren<T>(child))
                    {
                        yield return childOfChild;
                    }
                }
            }
        }
        private bool isLayoutUpdating = false;
        private void DataListView_LayoutUpdated(object sender, EventArgs e)
        {
            if (!isLayoutUpdating)
            {
                isLayoutUpdating = true;
                InvokeDataGridHeaderClick();
                isLayoutUpdating = false;
            }
        }

        public void ScrollToVerticalOffset(double offset)
        {
            VerticalScrollViewer.Value = offset;
        }
    }
}